// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from ..\gir-files-gstreamer
// from ..\gir-files-gtk
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperDiscovererDiscoveryMode")]
pub enum DiscovererDiscoveryMode {
    #[doc(alias = "CLAPPER_DISCOVERER_DISCOVERY_ALWAYS")]
    Always,
    #[doc(alias = "CLAPPER_DISCOVERER_DISCOVERY_NONCURRENT")]
    Noncurrent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DiscovererDiscoveryMode {
    type GlibType = ffi::ClapperDiscovererDiscoveryMode;

    #[inline]
    fn into_glib(self) -> ffi::ClapperDiscovererDiscoveryMode {
        match self {
            Self::Always => ffi::CLAPPER_DISCOVERER_DISCOVERY_ALWAYS,
            Self::Noncurrent => ffi::CLAPPER_DISCOVERER_DISCOVERY_NONCURRENT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperDiscovererDiscoveryMode> for DiscovererDiscoveryMode {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperDiscovererDiscoveryMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_DISCOVERER_DISCOVERY_ALWAYS => Self::Always,
            ffi::CLAPPER_DISCOVERER_DISCOVERY_NONCURRENT => Self::Noncurrent,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DiscovererDiscoveryMode {
    #[inline]
    #[doc(alias = "clapper_discoverer_discovery_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_discoverer_discovery_mode_get_type()) }
    }
}

impl glib::HasParamSpec for DiscovererDiscoveryMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DiscovererDiscoveryMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DiscovererDiscoveryMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DiscovererDiscoveryMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DiscovererDiscoveryMode> for glib::Value {
    #[inline]
    fn from(v: DiscovererDiscoveryMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperMarkerType")]
pub enum MarkerType {
    #[doc(alias = "CLAPPER_MARKER_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "CLAPPER_MARKER_TYPE_TITLE")]
    Title,
    #[doc(alias = "CLAPPER_MARKER_TYPE_CHAPTER")]
    Chapter,
    #[doc(alias = "CLAPPER_MARKER_TYPE_TRACK")]
    Track,
    #[doc(alias = "CLAPPER_MARKER_TYPE_CUSTOM_1")]
    Custom1,
    #[doc(alias = "CLAPPER_MARKER_TYPE_CUSTOM_2")]
    Custom2,
    #[doc(alias = "CLAPPER_MARKER_TYPE_CUSTOM_3")]
    Custom3,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MarkerType {
    type GlibType = ffi::ClapperMarkerType;

    #[inline]
    fn into_glib(self) -> ffi::ClapperMarkerType {
        match self {
            Self::Unknown => ffi::CLAPPER_MARKER_TYPE_UNKNOWN,
            Self::Title => ffi::CLAPPER_MARKER_TYPE_TITLE,
            Self::Chapter => ffi::CLAPPER_MARKER_TYPE_CHAPTER,
            Self::Track => ffi::CLAPPER_MARKER_TYPE_TRACK,
            Self::Custom1 => ffi::CLAPPER_MARKER_TYPE_CUSTOM_1,
            Self::Custom2 => ffi::CLAPPER_MARKER_TYPE_CUSTOM_2,
            Self::Custom3 => ffi::CLAPPER_MARKER_TYPE_CUSTOM_3,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperMarkerType> for MarkerType {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperMarkerType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_MARKER_TYPE_UNKNOWN => Self::Unknown,
            ffi::CLAPPER_MARKER_TYPE_TITLE => Self::Title,
            ffi::CLAPPER_MARKER_TYPE_CHAPTER => Self::Chapter,
            ffi::CLAPPER_MARKER_TYPE_TRACK => Self::Track,
            ffi::CLAPPER_MARKER_TYPE_CUSTOM_1 => Self::Custom1,
            ffi::CLAPPER_MARKER_TYPE_CUSTOM_2 => Self::Custom2,
            ffi::CLAPPER_MARKER_TYPE_CUSTOM_3 => Self::Custom3,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MarkerType {
    #[inline]
    #[doc(alias = "clapper_marker_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_marker_type_get_type()) }
    }
}

impl glib::HasParamSpec for MarkerType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MarkerType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MarkerType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MarkerType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MarkerType> for glib::Value {
    #[inline]
    fn from(v: MarkerType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperPlayerSeekMethod")]
pub enum PlayerSeekMethod {
    #[doc(alias = "CLAPPER_PLAYER_SEEK_METHOD_ACCURATE")]
    Accurate,
    #[doc(alias = "CLAPPER_PLAYER_SEEK_METHOD_NORMAL")]
    Normal,
    #[doc(alias = "CLAPPER_PLAYER_SEEK_METHOD_FAST")]
    Fast,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PlayerSeekMethod {
    type GlibType = ffi::ClapperPlayerSeekMethod;

    #[inline]
    fn into_glib(self) -> ffi::ClapperPlayerSeekMethod {
        match self {
            Self::Accurate => ffi::CLAPPER_PLAYER_SEEK_METHOD_ACCURATE,
            Self::Normal => ffi::CLAPPER_PLAYER_SEEK_METHOD_NORMAL,
            Self::Fast => ffi::CLAPPER_PLAYER_SEEK_METHOD_FAST,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperPlayerSeekMethod> for PlayerSeekMethod {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperPlayerSeekMethod) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_PLAYER_SEEK_METHOD_ACCURATE => Self::Accurate,
            ffi::CLAPPER_PLAYER_SEEK_METHOD_NORMAL => Self::Normal,
            ffi::CLAPPER_PLAYER_SEEK_METHOD_FAST => Self::Fast,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PlayerSeekMethod {
    #[inline]
    #[doc(alias = "clapper_player_seek_method_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_player_seek_method_get_type()) }
    }
}

impl glib::HasParamSpec for PlayerSeekMethod {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PlayerSeekMethod {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PlayerSeekMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PlayerSeekMethod {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PlayerSeekMethod> for glib::Value {
    #[inline]
    fn from(v: PlayerSeekMethod) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperPlayerState")]
pub enum PlayerState {
    #[doc(alias = "CLAPPER_PLAYER_STATE_STOPPED")]
    Stopped,
    #[doc(alias = "CLAPPER_PLAYER_STATE_BUFFERING")]
    Buffering,
    #[doc(alias = "CLAPPER_PLAYER_STATE_PAUSED")]
    Paused,
    #[doc(alias = "CLAPPER_PLAYER_STATE_PLAYING")]
    Playing,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PlayerState {
    type GlibType = ffi::ClapperPlayerState;

    #[inline]
    fn into_glib(self) -> ffi::ClapperPlayerState {
        match self {
            Self::Stopped => ffi::CLAPPER_PLAYER_STATE_STOPPED,
            Self::Buffering => ffi::CLAPPER_PLAYER_STATE_BUFFERING,
            Self::Paused => ffi::CLAPPER_PLAYER_STATE_PAUSED,
            Self::Playing => ffi::CLAPPER_PLAYER_STATE_PLAYING,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperPlayerState> for PlayerState {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperPlayerState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_PLAYER_STATE_STOPPED => Self::Stopped,
            ffi::CLAPPER_PLAYER_STATE_BUFFERING => Self::Buffering,
            ffi::CLAPPER_PLAYER_STATE_PAUSED => Self::Paused,
            ffi::CLAPPER_PLAYER_STATE_PLAYING => Self::Playing,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PlayerState {
    #[inline]
    #[doc(alias = "clapper_player_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_player_state_get_type()) }
    }
}

impl glib::HasParamSpec for PlayerState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PlayerState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PlayerState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PlayerState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PlayerState> for glib::Value {
    #[inline]
    fn from(v: PlayerState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperQueueProgressionMode")]
pub enum QueueProgressionMode {
    #[doc(alias = "CLAPPER_QUEUE_PROGRESSION_NONE")]
    None,
    #[doc(alias = "CLAPPER_QUEUE_PROGRESSION_CONSECUTIVE")]
    Consecutive,
    #[doc(alias = "CLAPPER_QUEUE_PROGRESSION_REPEAT_ITEM")]
    RepeatItem,
    #[doc(alias = "CLAPPER_QUEUE_PROGRESSION_CAROUSEL")]
    Carousel,
    #[doc(alias = "CLAPPER_QUEUE_PROGRESSION_SHUFFLE")]
    Shuffle,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for QueueProgressionMode {
    type GlibType = ffi::ClapperQueueProgressionMode;

    #[inline]
    fn into_glib(self) -> ffi::ClapperQueueProgressionMode {
        match self {
            Self::None => ffi::CLAPPER_QUEUE_PROGRESSION_NONE,
            Self::Consecutive => ffi::CLAPPER_QUEUE_PROGRESSION_CONSECUTIVE,
            Self::RepeatItem => ffi::CLAPPER_QUEUE_PROGRESSION_REPEAT_ITEM,
            Self::Carousel => ffi::CLAPPER_QUEUE_PROGRESSION_CAROUSEL,
            Self::Shuffle => ffi::CLAPPER_QUEUE_PROGRESSION_SHUFFLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperQueueProgressionMode> for QueueProgressionMode {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperQueueProgressionMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_QUEUE_PROGRESSION_NONE => Self::None,
            ffi::CLAPPER_QUEUE_PROGRESSION_CONSECUTIVE => Self::Consecutive,
            ffi::CLAPPER_QUEUE_PROGRESSION_REPEAT_ITEM => Self::RepeatItem,
            ffi::CLAPPER_QUEUE_PROGRESSION_CAROUSEL => Self::Carousel,
            ffi::CLAPPER_QUEUE_PROGRESSION_SHUFFLE => Self::Shuffle,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for QueueProgressionMode {
    #[inline]
    #[doc(alias = "clapper_queue_progression_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_queue_progression_mode_get_type()) }
    }
}

impl glib::HasParamSpec for QueueProgressionMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for QueueProgressionMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for QueueProgressionMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for QueueProgressionMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<QueueProgressionMode> for glib::Value {
    #[inline]
    fn from(v: QueueProgressionMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ClapperStreamType")]
pub enum StreamType {
    #[doc(alias = "CLAPPER_STREAM_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "CLAPPER_STREAM_TYPE_VIDEO")]
    Video,
    #[doc(alias = "CLAPPER_STREAM_TYPE_AUDIO")]
    Audio,
    #[doc(alias = "CLAPPER_STREAM_TYPE_SUBTITLE")]
    Subtitle,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for StreamType {
    type GlibType = ffi::ClapperStreamType;

    #[inline]
    fn into_glib(self) -> ffi::ClapperStreamType {
        match self {
            Self::Unknown => ffi::CLAPPER_STREAM_TYPE_UNKNOWN,
            Self::Video => ffi::CLAPPER_STREAM_TYPE_VIDEO,
            Self::Audio => ffi::CLAPPER_STREAM_TYPE_AUDIO,
            Self::Subtitle => ffi::CLAPPER_STREAM_TYPE_SUBTITLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ClapperStreamType> for StreamType {
    #[inline]
    unsafe fn from_glib(value: ffi::ClapperStreamType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::CLAPPER_STREAM_TYPE_UNKNOWN => Self::Unknown,
            ffi::CLAPPER_STREAM_TYPE_VIDEO => Self::Video,
            ffi::CLAPPER_STREAM_TYPE_AUDIO => Self::Audio,
            ffi::CLAPPER_STREAM_TYPE_SUBTITLE => Self::Subtitle,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for StreamType {
    #[inline]
    #[doc(alias = "clapper_stream_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::clapper_stream_type_get_type()) }
    }
}

impl glib::HasParamSpec for StreamType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for StreamType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StreamType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for StreamType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StreamType> for glib::Value {
    #[inline]
    fn from(v: StreamType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
